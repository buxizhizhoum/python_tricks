# 第六章 循环和迭代

## 6.1 编写python循环

找出最近转Python的开发人员中，具有C语言背景的人员的最简单方法之一就是看他们如何写循环。

例如，如下代码段时，就是有人在尝试用C或Java的风格写Python的一个例子：

    my_items = ['a', 'b', 'c']
    i = 0
    while i < len(my_items):
        print(my_items[i])
        i += 1

现在，这段代码有那些地方不符合Python风格？
两件事情：

首先，它手动维护索引`i`——将其初始化为零，然后在每次循环迭代时增加它。

其次，为了确定迭代次数，它使用len()来获取my_items容器的大小。

在Python中，你可以编写自动处理这两个问题的循环。
充分利用这一点是一个好主意。
例如，如果你不必处理索引，那么就很难编写意外的无限循环。
这也使代码更简洁，因此更具可读性。

为了重构这个代码示例，我将从删除手动更新索引的代码开始。
在Python中，一个好的方法是使用for循环。
使用内置的range()函数，我可以自动生成索引：

    >>> range(len(my_items))
    range(0, 3)
    >>> list(range(0, 3))
    [0, 1, 2]


range类型表示一个不可变的数字序列。
相对于列表来说，它只需要很小的内存。
range对象实际上并不存储代表数字序列的每个值，相反，它是一个迭代器，会实时计算序列值。

因此，与其在每次循环迭代中手动增加i，不如利用range()函数这么写：

    for i in range(len(my_items)):
        print(my_items[i])

这钟写法更好。
但是，它仍然不是很符合Python的风格，
它更像Java式的迭代结构，而不是Python的循环。
当你看到使用range(len(...))遍历容器的代码时，你通常可以进一步简化和改进它。

正如我提过的，在Python中，for循环实际上是for-each循环，
可以直接遍历容器或序列中的项目，而无需按索引查找它们。
我可以用它来简化这个循环：

    for item in my_items:
        print(item)

我认为这种方案是相当符合Python风格的。
它使用了几种先进的Python功能，但仍保持简洁美观，几乎就像编程教科书中的伪代码一样。
请注意一下这个循环是如何不再跟踪容器的大小并且不再使用索引访问元素。

容器本身现在负责产出元素，所以元素才可以被处理。
如果容器有序，则结果也将有序。
如果容器无需，结果也将无序，但循环仍将覆盖所有元素。

当然，你不可能一直可以像这样重写你的循环。
例如，如果你需要元素的索引时，该怎么办？

在不使用range(len(...))这种写法时，也可以编写循环来维护索引。
内置的enumerate()函数可帮助你使这些循环变得美观且符合Python风格：

    >>> for i, item in enumerate(my_items):
    ... print(f'{i}: {item}')
    0: a
    1: b
    2: c

你看，Python中的迭代器可以返回多个值。
他们可以返回具有任意数量元素的元组，然后可以for语句中对元组进行拆包。

这是非常强大的。
例如，你可以使用相同的方法同时遍历字典的键和值：

    >>> emails = {
    ... 'Bob': 'bob@example.com',
    ... 'Alice': 'alice@example.com',
    ... }
    >>> for name, email in emails.items():
    ... print(f'{name} -> {email}')
    'Bob -> bob@example.com'
    'Alice -> alice@example.com'

我想再举一个例子给你看。
如果你就是需要一个C风格的循环，该怎么办？
例如，如果你必须控制索引的步长？
想象一下，你从以下Java循环开始：

    for (int i = a; i < n; i += s) {
    // ...
    }

这种模式如何转换到Python？
range()函数再次救场——它接受可选参数来控制循环的起始值(a)，结束值(n)和步长(s)。

因此，我们的Java循环可以转换成像下面的Python语句：

    for i in range(a, n, s):
        # ...

### 重点

- C风格的循环是不符合Python风格的。尽可能避免手动管理循环的索引和停止条件。
- Python的for循环实际上是for-each循环，它可以直接从容器或序列对元素进行迭代。


## 6.2 解析

我最喜欢的Python功能之一就是列表解析。
他们乍一看似乎有些不可思议，但是当你将它们分解时，它们实际上是一个非常简单的结构。

理解列表解析的关键在于，它们只是用了一种更简洁和紧凑语法对一个数据集进行了for循环。

这有时也称为语法糖，是让我们这些Python程序员更轻松一点的常用功能的简写。
以以下列表解析为例：

    >>> squares = [x * x for x in range(10)]

它计算从零到九的所有整数的平方：

    >>> squares
    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

如果你想使用普通的for循环构建相同的列表，则可能需要这样写：

    >>> squares = []
    >>> for x in range(10):
    ...     squares.append(x * x)

那是一个非常简单的循环，对不对？
如果你回过头来比较列表解析的示例和for循环示例，找出共同点，那么最终会总结出一些模式。
通过概括一些常见的结构，你最终将总结出类似于以下的模板：

    values = [expression for item in collection]

上面的列表解析模板等效于下面的普通for循环：

    values = []
    for item in collection:
        values.append(expression)

在这里，我们首先创建一个新的列表实例以接收输出值。
然后，我们遍历容器中的所有元素，用任意表达式对每个元素进行转换，然后将结果添加到输出列表。

这是一个千篇一律的模式，你可以将其应用于许多for循环以将其转化为列表解析，反之亦然。
现在，我们需要在此模板中添加一个更有用的部分，那就是根据条件过滤元素。

列表解析可以基于一些任意条件来过滤值，这些条件决定结果值是否成为输出列表的一部分。
这是一个例子：

    >>> even_squares = [x * x for x in range(10)
                        if x % 2 == 0]

这个列表解析将计算从零到九的整数中所有偶数的平方。
此处使用的模(％)运算符返回一个数字除以另一个后的余数。
在此示例中，我们将使用它来测试数字是否为偶数。
结果如下：

    >>> even_squares
    [0, 4, 16, 36, 64]

与第一个示例类似，这种列表解析也可以转换为等效的for循环：

    even_squares = []
    for x in range(10):
        if x % 2 == 0:
            even_squares.append(x * x)

让我们尝试概括一下列表解析到for循环的转换模式。
这次我们要在模板中添加一个过滤条件，因此我们可以决定最终那个元素会输出到最终的结果列表。
这是更新的列表解析模板：

    values = [expression
    　　　　　　for item in collection
            　if condition]

同样，我们可以将列表解析转换为for循环：

    values = []
    for item in collection:
        if condition:
            values.append(expression)

再一次，这是一个简单的转换——我们只是应用了更新后的模式。
我希望这能消除一些与列表解析如何工作相关的“魔术”。
这是一个所有Python程序员都应该知道如何使用的有效工具。

在继续之前，我想指出Python不仅仅支持列表解析，
还有类似的语法糖用于支持集合和字典。
集合解析如下：

    >>> { x * x for x in range(-9, 10) }
    set([64, 1, 36, 0, 49, 9, 16, 81, 25, 4])

与列表保留了元素的顺序不同，Python集是无序的。
因此，将元素添加到集合中时，结果的顺序将或多或少“随机”过。

这是字典解析：

    >>> { x: x * x for x in range(5) }
    {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

两者在实践中都是有用的工具。
不过，对于Python的解析有一个警告：
随着你越来越熟练地使用它们，编写难以阅读的代码会变得越来越容易。
一不小心就可能不得不处理可怕的列表，集合和字典。、
请记住，过犹不及。

经过一番苦恼之后，我个人将底线定在一层嵌套的列表解析。
我发现在超过一层嵌套之后，大多数情况下使用for循环效果会更好（“更易读”和“更易于维护”）。

### 重点

- 解析表达式是Python中的关键功能。理解并应用它们将使你的代码更加Pythonic。
- 解析表达式只是for循环的语法糖。了解了模式之后，你会对解析表达式有更深的理解。
- 列表解析之外还有其它的解析表达式。


## 6.3 列表切片技巧

Python的列表对象具有一项巧妙的功能，称为切片。
它是方括号索引语法的扩展。
切片通常用于访问有序集合中一个范围内的元素。
例如，你可以将一个大型列表对象切成多个较小的子列表。

这是一个例子。
切片使用常见的“[]”语法，使用`[start：stop：step]`模式：

    >>> lst = [1, 2, 3, 4, 5]
    >>> lst
    [1, 2, 3, 4, 5]
    # lst[start:end:step]
    >>> lst[1:3:1]
    [2, 3]

添加`[1:3:1]`索引返回原始列表的一部分，这个部分从索引1开始到索引2结束，步长为一个元素。
为了避免边界条件错误，要记住上限永远不包含在内。
这就是为什么`[1:3:1]`切片会返回`[2,3]`子列表的原因。
如果你忽略步长，则默认为一：

    >>> lst[1:3]
    [2, 3]

你还可以使用step参数执行其他有趣的操作。
例如，你可以从原始列表每隔1个元素取一个以创建子列表：

    >>> lst[::2]
    [1, 3, 5]

你刚刚看到切片步长如何用于从原始列表中每隔1个取1个元素。
好吧，还有更多：
如果你使用`[::-1]`切片，你将获得一个原始列表的副本，只是顺序相反：

    >>> numbers[::-1]
    [5, 4, 3, 2, 1]

我们使用(::)要求Python提供一个完整的列表，然后通过将步长设置为-1，从后到前排遍历所有元素。
好整洁，但在大多数情况下，我仍然坚持使用list.reverse()和内置的reversed()函数转列表。

这是另一个列表切片技巧：你可以使用:操作符清除列表中的所有元素，而不会销毁列表对象本身。

当你需要清除程序中具有其他引用指向的列表时，这非常有用。
在这种情况下，你通常不能仅仅通过用新列表对象替换旧列表来清空列表，因为引用不会更新：

    >>> lst = [1, 2, 3, 4, 5]
    >>> del lst[:]
    >>> lst
    []

如你所见，这将删除lst中的所有元素，但列表象本身完好无损。
在Python 3中，你还可以使用lst.clear()实现同样的同能，这可能是更具可读性的模式。
但是，Python 2无法使用clear()。

除了清除列表，你还可以使用`:`操作符在不创建新列表的前提下替换所有元素。
这是一个清除列表，然后手动重新填充它例子：

    >>> original_lst = lst
    >>> lst[:] = [7, 8, 9]
    >>> lst
    [7, 8, 9]
    >>> original_lst
    [7, 8, 9]
    >>> original_lst is lst
    True

前面的代码示例替换了lst中的所有元素，但没有销毁并重新创建列表本身。
之前对列表对象的引用仍然有效。

`:`操作符的另一个用途是创建浅拷贝：

    >>> copied_lst = lst[:]
    >>> copied_lst
    [7, 8, 9]
    >>> copied_lst is lst
    False

创建浅拷贝意味着仅元素的结构被复制，而不是元素本身。
列表的两个副本共享各个元素的相同实例。

如果你需要复制包括元素在内的所有内容，那么你需要创建列表的深拷贝。
Python内置的copy模块可以实现这个功能。

### 重点

- `:`操作符不仅对选择子列表有用，它也可以用于清除，反转，并复制列表。
- 但要小心——这个功能对许多Python开发人员有点神秘，使用它可能会降低你的代码的可维护性。


## 6.4 漂亮的迭代器

与许多其他编程语言的语法相比，Python的语法很简洁。
让我们以`for-in`循环为例。
这样简洁的循环，就好像是一个英语句子：

    numbers = [1, 2, 3]
    for n in numbers:
        print(n)
        
Python这样优雅的循环是如何实现的呢？
循环如何从正在循环的对象中获取每个元素？
在你自己的Python对象中如何才能支持相同的编程风格？

你可以在Python的迭代器协议中找到这些问题的答案：
支持`__iter__`和`__next__`双下划线方法的对象会自动支持for-in循环。

让我们一步步来。
和装饰器一样，迭代器及其的相关技术乍一看非常神秘和复杂。
因此，我们将简化它们。

在本章中，你将看到如何编写多个支持迭代器协议的Python类。
它们是“非魔术”示例，这是你建立并加深理解的一些测试实现。

首先，我们排除任何不必要的环节，把重点放在介绍Python 3中迭代器的核心机制上，
因此你可以清楚地看到迭代器在底层怎么运行。

我会将每个示例都与我们刚开始提到的for-in循环问题联系在一起。
并且，在本章的最后，我们将讨论一些迭代器在Python 2和Python 3之间的差异。

准备好了吗？让我们开始吧！

### 永远迭代

首先，我们从编写一个演示最基本的迭代器协议的类开始。
我在这里使用的示例看起来可能与你在其他迭代器教程中看到的示例不同。
我认为通过这种方式可以让你更了解迭代器在Python中的工作方式。

在接下来的几段中，我们将实现一个名为`Repeater`的类，这个类可以使用for-in循环进行迭代，
如下所示：

    repeater = Repeater('Hello')
    for item in repeater:
        print(item)
    
顾名思义，这个Repeater类的实例在迭代时将重复返回单个值。
所以上面的例子将永远在控制台上输出字符串“Hello”。
首先，我们先定义并实现`Repeater`：

    class Repeater:
        def __init__(self, value):
            self.value = value
            
        def __iter__(self):
            return RepeaterIterator(self)
        
第一次看时，Repeater看起来像是标准的Python类。
但是注意，它还包含了__iter__方法。

我们从__iter__创建并返回的RepeaterIterator对象是什么？
这是为了让for-in迭代示例可以运行需要定义的一个帮助类：

    class RepeaterIterator:
        def __init__(self, source):
            self.source = source
            
        def __next__(self):
            return self.source.value
        
同样，`RepeaterIterator`看起来像一个简单的Python类，
但你可能要注意以下两件事：

  1.在`__init__`方法中，我们将每个`RepeaterIterator`的都链接到创建它的Repeater对象。
  这样我们可以保持被迭代的“源”对象。
  
  2.在`RepeaterIterator.__ next__`中，我们返回到“源”（Repeater实例）并返回它关联的值。
    
在此代码示例中，Repeater和RepeaterIterator一起支持了Python的迭代器协议。
我们定义的两个下划线方法__iter__和__next__是实现Python可迭代对象的关键。

我们接下来会仔细研究这两种方法，我们会对已有的代码进行一些实验，然后看看他们怎么运行。
让我们确认一下这个两个类确实使Repeater对象可以通过for-in循环迭代。
我们将首先创建一个Repeater实例，该实例将一直返回字符串“Hello”：

    >>> repeater = Repeater('Hello')
    
现在，我们尝试使用for-in循环。当你运行以下代码时会发生什么？

    >>> for item in repeater:
    ... print(item)
    
你会看到很多“Hello”输出到屏幕上。
Repeater一直输出同样的字符串到屏幕，并且这个循环永远不会结束。
我们的程序注定要永远打印'Hello'到控制台：

    Hello
    Hello
    Hello
    Hello
    Hello
    ...
    
恭喜——你刚刚用Python写了一个可以运行的迭代器，并且和for-in循环一起使用。
循环可能还没有结束……但是到目前为止，没有什么问题。

接下来，我们将梳理这个示例，以了解__iter__和__next__方法如何让Python对象可迭代。

提示：如果你运行了最后一个示例，现在想要停止它，请按几次 `Ctrl + C` 以摆脱无限循环。

### for-in循环在Python中如何工作？

很明显我们的Repeater类支持迭代器协议，我们运行了一个for-in循环来证明它：

    repeater = Repeater('Hello')
    for item in repeater:
        print(item)

现在，这个for-in循环在底层做了什么？
它是如何与`Repeater`对象通信并从中获取新元素的？

为了消除某些“魔法”，我们可以将此循环扩展为一个长一点的版本，两者具有相同的结果：

    repeater = Repeater('Hello')
    iterator = repeater.__iter__()
    while True:
        item = iterator.__next__()
        print(item)

如你所见，for-in只是一个简单`while`循环的语法糖：

- 它首先通过调用`__iter__`方法让`repeater`对象准备进行迭代。这返回了实际的迭代器对象。
- 之后，循环反复调用迭代器对象的`__next__`方法从中检索值。

如果你使用过数据库游标，这个思维模型看起来会很熟悉：
我们首先初始化游标并准备进行读取，
然后我们可以根据需要将数据读取到局部变量中，一次一个元素。

因为正在处理中的元素不超过一个，所以这种方法具有很高的内存使用效率。
我们的Repeater类提供了一个无限的元素序列，我们可以对其进行迭代。
用Python列表模拟同样的事情是不可能的——
我们不可能一开始就创建一个具有无限元素的列表。
这使得迭代器成为一个非常强大的概念。

用更抽象的术语讲，迭代器提供了一个通用接口，
它可让你在与容器的内部结构完全隔离的情况下，处理容器的每个元素。

无论你要处理的是列表，字典，无限序列（比如Repeater类提供的这种）或其它序列类型——所有这些都只是实现细节。 每一个
每个这种对象，都可以使用迭代器以相同的方式进行遍历。

如你所见，在Python中for-in循环并没有什么特别的。
如果你探究一下底层的原理，归根结底是在正确的时间调用正确的双下划线方法。
实际上，你可以在Python解释器会话中手动“模拟”循环如何使用迭代器协议：

    >>> repeater = Repeater('Hello')
    >>> iterator = iter(repeater)
    >>> next(iterator)
    'Hello'
    >>> next(iterator)
    'Hello'
    >>> next(iterator)
    'Hello'
    ...

这输出了相同的结果——无限的`Hello`流。
每次你调用`next()`时，迭代器都输出相同的问候。

顺便说一下，我在这里用Python内置函数`iter()`和`next()`取代了对`__iter__`和`__next__`的调用。

在内部，这些内置函数调用相同的双下划线方法，
但是通过提供一个迭代器协议的整洁“门面”，它们让代码更整洁，更易读。

Python还为其它方法提供了快捷方式。
例如，`len(x)`是调用`x.__ len__`的快捷方式。
相似地，调用`iter(x)`最终会调用`x.__iter__`，
调用`next(x)`最终会调用`x.__ next__`。

通常，最好使用内置的函数，而不是直接调用实现协议的双下划线方法。
它会使代码更易于阅读。

### 一个简单的迭代类

到目前为止，我们的迭代器示例由`Repeater`和`RepeaterIterator`两个单独的类组成。
他们直接对应于Python的迭代器协议的两个阶段：

首先，通过调用`iter()`创建迭代器对象，
然后通过`next()`从中获取值。

很多时候，这两项职责可以由一个类承担。
在编写基于类的迭代器时，这样做可以减少所需的代码量。

我不选择在本章的第一个示例这么做，
是因为它让迭代器协议背后的心理模型不再清晰。
但是现在你已经了解了如何用更长，更复杂的方法编写基于类的迭代器，
接下来让我们花一点时间来简化一下我们目前的代码。

还记得为什么我们需要`RepeaterIterator`类吗？
我们需要它来承载`__next__`方法以从迭代器中获取新值。
但是`__next__`在哪里定义并不重要。
在迭代器协议中，重要的是`__iter__`要返回带有`__next__`方法的对象。

所以这里有个想法：`RepeaterIterator`一直返回相同的值，不必跟踪任何内部状态。
如果我们直接将`__next__`方法添加到`Repeater`类中会怎么样？

这样，我们可以完全摆脱`RepeaterIterator`，并用单个Python类实现一个可迭代的对象。
让我们试试！我们新的简化后的迭代器示例如下：

    class Repeater:
        def __init__(self, value):
            self.value = value
            
        def __iter__(self):
            return self
            
        def __next__(self):
            return self.value

我们从10行代码的两个单独的类简化到了7行代码的一个类。
我们简化的实现仍然很好地支持迭了代器协议：

    >>> repeater = Repeater('Hello')
    >>> for item in repeater:
    ... print(item)
    Hello
    Hello
    Hello
    ...

简化这样基于类的迭代器通常很有意义。
实际上，大多数Python的迭代器教程都是以这种方式开始的。
但是我总是觉得从一开始就用一个类来解释迭代器没有揭示迭代器协议的底层的原理，
因此使其难以理解。

### 谁想一直迭代

现在，你应该对Python迭代器的工作方式有一个很好的理解。
但是到目前为止，我们仅实现了一直迭代的迭代器。

显然，无限重复并不是迭代器的主要使用场景。
实际上，当你从头到尾回顾整个过程时，在本章中，我使用以下代码段作为开始的示例：

    numbers = [1, 2, 3]
    for n in numbers:
        print(n)

你会期望上面的代码打印数字1、2和3，然后停下来。
你不会期望它在你的终端一直打印“3”，直到你在慌乱中使用了Ctrl + C…

因此，是时候看看怎么编写最后能够停止生成新值，而不是永远迭代下去的迭代器了，
因为那才是我们在for-in循环中使用迭代器时典型的表现。

现在，我们来编写另一个迭代器类，称为`BoundedRepeater`。
它与之前的`Repeater`示例相似，但是这次我们希望它在预设的重复次数后停止。

让我们考虑一下。
我们如何做到这一点？迭代器如何在没有元素要迭代时发出信号？
也许你在想，“嗯，我们可以在`__next__`方法返回None。”

那不是一个坏主意，但问题是，如果我们希望某些迭代器能够返回None做为可接受的值时应该怎么办？

让我们看看其他迭代器是怎么解决这个问题的。
我将构造一个简单的容器，一个包含一些元素的列表，然后我将对其进行迭代，直到用完所有元素以查看发生了什么事情：

    >>> my_list = [1, 2, 3]
    >>> iterator = iter(my_list)

    >>> next(iterator)
    1
    >>> next(iterator)
    2
    >>> next(iterator)
    3

注意！我们已经使用了列表中的仅有的三个可用元素。
看看如果再次在迭代器上调用`next`会发生什么：

    >>> next(iterator)
    StopIteration

啊哈！它将抛出StopIteration异常，表明我们已经耗尽了迭代器中所有可用的值。

没错：迭代器使用异常来构造控制流。
Python迭代器通过抛出内置StopIteration异常，表示迭代结束。

如果我不断要求迭代器提供更多值，它将不断抛出StopIteration异常，以表示没有更多值可迭代了：

    >>> next(iterator)
    StopIteration
    >>> next(iterator)
    StopIteration
    ...

一旦耗尽，Python迭代器通常无法“重置”，他们应该在每次调用next()时抛出StopIteration异常。
如果要重新进行迭代，需要使用iter()函数构造一个新的迭代器对象。

现在我们知道编写`BoundedRepeater`类所需的一切了，它会在设定的重复次数后停止迭代：

    class BoundedRepeater:
        def __init__(self, value, max_repeats):
            self.value = value
            self.max_repeats = max_repeats
            self.count = 0

        def __iter__(self):
            return self

        def __next__(self):
            if self.count >= self.max_repeats:
                raise StopIteration
            self.count += 1
            return self.value

这给出了我们想要的结果。
迭代器在迭代了`max_repeats`参数定义的迭代次数后停止了：

    >>> repeater = BoundedRepeater('Hello', 3)
    >>> for item in repeater:
        print(item)
    Hello
    Hello
    Hello

如果我们去掉语法糖，重写这个for-in循环示例，我们得到了下面展开后的代码片段：

    repeater = BoundedRepeater('Hello', 3)
    iterator = iter(repeater)
    while True:
        try:
            item = next(iterator)
        except StopIteration:
            break
        print(item)

每次在此循环中调用`next()`时，我们都会检查StopIteration异常，并在必要时中断while循环。

能够编写三行的for-in循环而不是八行的while循环是一个不错的改进。
它使代码更容易阅读且更易于维护。
这是Python中迭代器如此强大的另一个原因。

### Python2.x 兼容

我在这里展示的所有代码示例都是用Python 3编写的。
在实现基于类的迭代器时，Python 2和3之间的区别很小但却很重要：

- 在Python 3中，从迭代器获取下一个值的方法称为`__next__`。
- 在Python 2中，相同的方法称为`next`（不带下划线）。

如果你尝试编写应该在两种版本的Python上都可以使用的基于类的迭代器，这种命名差异可能会导致一些问题。
幸运的是，你可以采用一种简单的方法来绕过这种差异。

这是InfiniteRepeater类的更新版本，
适用于Python 2和Python 3：

    class InfiniteRepeater(object):
        def __init__(self, value):
            self.value = value
        
        def __iter__(self):
            return self
        
        def __next__(self):
            return self.value
        
        # Python 2 compatibility:
        def next(self):
            return self.__next__()

为了使该迭代器类与Python 2兼容，我对其做了两个小改进：

首先，我添加了一个next方法，该方法仅调用原始的__next__并转发其返回值。
这实际是现有的__next__实现的别名，这样Python 2就可以找到它。
这样我们就可以支持两个版本的Python，同时所有实现细节仍然集中在一处。

其次，我修改了类定义，让类继承自object，确保我们在Python 2上创建的是新式类。
这与迭代器没有任何关系，但尽管如此这是一个好习惯。

### 重点

- 迭代器为Python对象提供了一个序列接口，它具有很高的内存使用效率，并且是Pythonic的。看漂亮的for-in循环！
- 为了支持迭代，对象需要提供`__iter__`和`__next__`双下划线方法来实现迭代器协议。
- 基于类的迭代器只是在Python中编写可迭代对象的一种方法。还有生成器和生成器表达式。

## 6.5 生成器是简化的迭代器

在关于迭代器的章节中，我们花了大量时间编写基于类的迭代器。
从教育的观点来看，这并不是一个坏主意——但它也表明了编写一个迭代器类需要很多样板代码。
说实话，作为一个“懒惰”的开发人员，我不喜欢乏味且重复的工作。

但是，迭代器在Python中是如此有用。
它们让你写出漂亮的for-in循环，可使你的代码更Pythonic并且更加高效。
如果有一种更简便的方法来编写这些迭代器……

Python再一次为我们提供了一些语法糖，使编写迭代器变得更加容易。
在本章中，你将看到如何使用生成器和yield关键字用更少的代码更快地编写迭代器。

### 无限的生成器

让我们再次来看一下我之前用来介绍迭代器概念的`Repeater`示例。它
实现了基于类的迭代器，循环遍历无限序列。
这是该类在其第二个（简化版）版本中的实现：

    class Repeater:
        def __init__(self, value):
            self.value = value
            
        def __iter__(self):
            return self
            
        def __next__(self):
            return self.value
            
如果你在想，“对于这样一个简单的迭代器来说，代码有点多，”你这么想是对的。
这个类的某些部分看起来是公式化的，好像它们在不同的基于类的迭代器中以完全相同的方式编写。

这是Python的生成器发挥作用的地方。
如果我把这个迭代器改写成生成器的，它看起来像这样：

    def repeater(value):
        while True:
            yield value
            
对于这里发生的事情来说这确实是一个很合适的思维模式。
你看到，当在函数内部调用return语句时，它永久地将控制权传递回该函数的调用者。
当yield被调用时，它同样会将控制权传回给函数的调用者——但是它只是暂时的。

而return语句丢弃了函数的局部状态，
yield语句挂起该函数并保留其局部状态。
实际上，这意味着生成器函数的局部变量和执行状态只是暂时隐藏而不是完全扔掉。
可以随时通过在生成器上调用next()恢复执行：

    >>> iterator = repeater('Hi')
    >>> next(iterator)
    'Hi'
    >>> next(iterator)
    'Hi'
    >>> next(iterator)
    'Hi'

这使生成器与迭代器协议完全兼容。
因此，我喜欢将它们看作是实现迭代器的语法糖。

你会发现，对于大多数类型的迭代器，编写生成器函数与定义一个基于类的迭代器相比，会更容易并且更具可读性。

### 可以停止的生成器

在本章中，我们再次通过编写一个无限生成器开始。
现在，你可能想知道如何编写一个一段时间后停止产生值的生成器，而不是持续不断地运行。

记住，在基于类的迭代器中，我们能够通过手动抛出StopIteration异常发出结束信号。
因为生成器与基于类的迭代器完全兼容，底层的实现原理也是一样的。

幸运的是，作为程序员，这次我们可以使用一个更好的接口。
一旦控制流通过除了yield语句外的其它任何方式从生成器函数返回，生成器就停止生成值。
这意味着你完全不必自己操心去抛出StopIteration！
这是一个例子：

    def repeat_three_times(value):
        yield value
        yield value
        yield value


请注意，该生成器函数不包含任何循环。
实际上，它非常简单，仅包含三个yield语句。
如果yield暂时挂起该函数的执行并返回值给调用者，当我们到达这个生成器的末尾时会发生什么？
让我们看看：

    >>> for x in repeat_three_times('Hey there'):
    ...     print(x)
    'Hey there'
    'Hey there'
    'Hey there'

如你所料，此生成器在三次迭代后停止生成新值。
我们可以假设它是通过在执行到达末尾时，抛出StopIteration异常实现的。
但是为了确定，让我们通过另一个实验来确认这一点：

    >>> iterator = repeat_three_times('Hey there')
    >>> next(iterator)
    'Hey there'
    >>> next(iterator)
    'Hey there'
    >>> next(iterator)
    'Hey there'
    >>> next(iterator)
    StopIteration
    >>> next(iterator)
    StopIteration

该迭代器的行为与我们预期的一样。
我们一到达生成器函数的末尾，它就不断抛出StopIteration来表示没有更多的值了。

让我们回到迭代器章节的另一个例子。
`BoundedIterator`类实现了一个迭代器，该迭代器仅重复设定的次数：

    class BoundedRepeater:
        def __init__(self, value, max_repeats):
            self.value = value
            self.max_repeats = max_repeats
            self.count = 0

        def __iter__(self):
            return self

        def __next__(self):
            if self.count >= self.max_repeats:
                raise StopIteration
            self.count += 1
            return self.value

我们为什么不尝试将BoundedRepeater类重新实现为生成器函数呢。这是我的第一个实现：

    def bounded_repeater(value, max_repeats):
        count = 0
        while True:
            if count >= max_repeats:
                return
            count += 1
            yield value

我故意使该函数中的while循环有点笨拙。
我想要演示如何从生成器中调用return语句如何使迭代因StopIteration异常而停止。
我们很快就会清理并简化这个生成器函数，
但是首先，让我们尝试一下到目前为止我们得到的生成器：

    >>> for x in bounded_repeater('Hi', 4):
    ...     print(x)
    'Hi'
    'Hi'
    'Hi'
    'Hi'

现在我们有了一个生成器，它会在重复配置的次数之后停止生成值。
它使用yield语句来传回值，直到最终命中return语句并停止迭代。

就像我向你保证的那样，我们可以进一步简化这个生成器。
我们会利用Python在每个函数的末尾都添加了一个隐式的return None语句这个事实。
这是我们最终的实现方式：

    def bounded_repeater(value, max_repeats):
        for i in range(max_repeats):
            yield value

你可以随时去确认这个简化的生成器是否可以正常工作。
考虑到所有因素，我们从BoundedRepeater类这个12行的实现转换为基于生成器的3行实现，两者功能完全相同。
代码量减少了75％——还不赖！

如你所见，生成器可简化掉编写基于类的迭代器所需的大部分样板代码。
他们可以使你的生活更加轻松，并让你编写更简洁，更短且更易于维护的迭代器。
生成器函数在Python中是一个很棒的功能，你在你自己的程序中使用它们时不应该犹豫。

### 重点

- 生成器函数是用于编写支持迭代器协议对象的语法糖。生成器可简化掉编写基于类的迭代器时所需的大部分样板代码。
- yield语句使你可以临时挂起生成器函数的执行并从中传递值。
- 控制流以yield以外的任何方式离开生成器函数后，生成器都会抛出StopIteration异常


## 6.6 生成器表达式

当我进一步了解Python的迭代器协议及其实现的不同方法后，
我意识到“语法糖”是一个反复出现的主题。

你会看到，基于类的迭代器和生成器函数是相同设计模式的两个实现方式。

生成器函数为你提供了在你自己的代码中支持迭代器协议的捷径，
并且避免了基于类的迭代器中的大量样板代码。
借助一些专门的语法或语法糖，它们可以节省你的时间，让你的生活更加容易。

这是Python和其他编程语言中经常出现的主题。
随着越来越多的开发人员在其程序中使用设计模式，
语言创作者越来越有动力为其提供抽象和实现捷径。

这就是编程语言随着时间的推移而发展的方式——作为开发人员，我们将从中受益。
我们开始使用越来越多的功能强大的模块，
从而减少了工作量并使我们事倍功半。

在本书前面的章节，
你看到了生成器如何为编写基于类的迭代器提供语法糖。
我们在这一节要讲到的的生成器表达式在外层又添加了另一层语法糖。

生成器表达式为你提供了更有效编写迭代器的快捷方式。
使用看起来像列表解析的简单明了的语法，
你可以用一行中代码定义迭代器。
这是一个例子：

    iterator = ('Hello' for i in range(3))

迭代时，这个生成器表达式产生的值与我们在上一章中写的`bounded_repeater`生成器函数的值相同。
在这里再次复习一下：

    def bounded_repeater(value, max_repeats):
        for i in range(max_repeats):
            yield value
    iterator = bounded_repeater('Hello', 3)

现在单行生成器表达式可以实现以前需要四行生成器函数或更长的基于类的迭代器才能实现的功能，
这难道不令人震惊吗？

但是我要超越自己。
确保我们使用生成器表达式定义的迭代器运行起来和我们的预期一致：

    >>> iterator = ('Hello' for i in range(3))
    >>> for x in iterator:
    ...     print(x)
    'Hello'
    'Hello'
    'Hello'

这看起来不错！
我们从一行的生成器表达式和bounded_repeater生成器函数似乎得到了相同的结果。

不过，有一个小警告：
一旦生成器表达式被消耗完，它就再也无法重新启动或重用。
所以在某些情况下使用生成器函数或基于类的迭代器有一些优势。

### 生成器表达式与列表解析

如你所知，生成器表达式与列表解析有点相似：

    >>> listcomp = ['Hello' for i in range(3)]
    >>> genexpr = ('Hello' for i in range(3))

但是，与列表解析不同，生成器表达式不会构造列表对象。
相反，它们和基于类的迭代器或生成器函数一样“实时”生成值。

将生成器表达式赋值给变量后会得到可迭代的“生成器对象”：

    >>> listcomp
    ['Hello', 'Hello', 'Hello']
    >>> genexpr
    <generator object <genexpr> at 0x1036c3200>

要访问生成器表达式产生的值，你需要调用`next()`，这和其他迭代器是一样的：

    >>> next(genexpr)
    'Hello'
    >>> next(genexpr)
    'Hello'
    >>> next(genexpr)
    'Hello'
    >>> next(genexpr)
    StopIteration

另外，你也可以在生成器表达式上调用`list()`函数，以构造一个包含所有值的列表对象：

    >>> genexpr = ('Hello' for i in range(3))
    >>> list(genexpr)
    ['Hello', 'Hello', 'Hello']

当然，这只是一个玩具示例，
展示了如何将生成器表达式“转换”（或与此相关的任何其他迭代器）为列表。
如果你需要使用的是列表对象，通常只需从一开始就编写一个列表解析。

让我们仔细看看这个简单的生成器表达的句法结构。
你开始看到的模式应该像这样：

    genexpr = (expression for item in collection)

上面的生成器表达式“模板”对应于以下的生成器函数：

    def generator():
        for item in collection:
            yield expression

就像列表推导一样，这为你提供了一种千篇一律的模式，
你可以将其应用于许多生成器函数，然后将它们转换成简明的生成器表达式。

### 过滤值

我们可以对该模板添加更多有用的功能，这是根据条件过滤的元素。
这是一个例子：

    >>> even_squares = (x * x for x in range(10)
                        if x % 2 == 0)

这个生成器产出从零到九的所有偶数的平方。
使用%（模）运算符的过滤条件会过滤掉任何不能被二整除的值：

    >>> for x in even_squares:
    ...     print(x)
    0
    4
    16
    36
    64

让我们更新一下生成器表达式模板。
通过添加if条件对元素进行过滤后，模板现在是这样的：

    genexpr = (expression for item in collection
              if condition)

该模式对应于一个相对简单但更长的生成器函数。最佳语法糖：

    def generator():
        for item in collection:
            if condition:
                yield expression

### 一行的生成器表达式

因为生成器表达式是表达式，所以你可以将它们与其他语句一起使用。
例如，你可以定义一个迭代器，并通过for循环立即使用它：

    for x in ('Bom dia' for i in range(3)):
        print(x)

你还可以使用另一种语法技巧来使你的生成器表达式更简洁。
如果将生成器表达式用作函数的单个参数，生成器表达式周围的括号可以去掉：

    >>> sum((x * 2 for x in range(10)))
    90
    # Versus:
    >>> sum(x * 2 for x in range(10))
    90

这可以使你编写简洁而高效的代码。
因为生成器表达式和基于类的迭代器以及生成器函数一样“实时”生成值，所
以它们的内存使用效率非常高。

### 过犹不及……

与列表推导类似，生成器表达式的复杂度比我们目前为止介绍的更高。
通过嵌套for循环和链接过滤语句，它们可以涵盖更广泛的使用场景：

    (expr for x in xs if cond1
          for y in ys if cond2
          ...
          for z in zs if condN)

上面的模式转换为下面的生成器函数：

    for x in xs:
        if cond1:
            for y in ys:
                if cond2:
                    ...
                        for z in zs:
                            if condN:
                                yield expr

这是我要提醒的地方：

请不要像这样写深层嵌套的生成器表达式。
从长远来看它们会很难维护。

这是一种“过犹不及”的情况，
即使是一个简单漂亮的工具，过度使用也会导致难以阅读和难以调试的程序。

和列表解析一样，我个人尽量远离任何包含两层以上嵌套的生成器表达式。

生成器表达式是你工具箱中一个有用的工具，
但这并不意味着应该将其用于你遇到的每个问题。
对于复杂的迭代器，编写一个生成器函数，甚至是一个基于类的迭代器会更合适。

如果你需要使用嵌套生成器和复杂的过滤条件，
通常最好抽出子生成器（这样你可以命名它们），
然后将它们在顶层链接在一起。
你会在下一章（连接迭代器）看到如何实现这种操作。

在你束手无策时，可以尝试不同的实现，然后选择可读性最高的实现。
相信我，长远来看这可以节省你的时间。

### 重点
- 生成器表达式类似于列表解析。但是，它们不构造列表对象。
  相反，生成器表达式像基于类的迭代器或者生成器函数那样“实时”生成值。
- 生成器表达式一旦被消耗，就不能重新启动或重用。
- 生成器表达式最适合实现简单的“临时”迭代器。
  对于复杂的迭代器，最好编写生成器函数或基于类的迭代器。
  
## 6.7 连接迭代器

这是Python迭代器的另一个重要功能：
通过连接多个迭代器，你可以编写高效的数据处理“管道”。
我第一次大卫·比兹利（David Beazley）在PyCon的演讲中看到这种模式，那让我大吃一惊。

利用Python的生成器函数和生成器表达式，你可以迅速构建简洁而强大的迭代器链。
在本章中，你将了解这种技术在实践中的表现以及如何在自己的程序中使用它。

快速回顾一下，生成器和生成器表达式是用Python编写迭代器的语法糖。
他们精简了许多编写基于类的迭代器时需要的样板代码。

常规函数产生单个返回值时，生成器产出一系列值。
你可以说他们在其生命周期产出了一个数据流。

例如，我可以定义以下生成器，
通过保持一个运行中的计数器并在每次调用next()时产出一个新值，
它可以产出从1到8的一系列整数值：

    def integers():
        for i in range(1, 9):
            yield i

你可以通过在Python交互解释器上运行下面的代码进行确认：

    >>> chain = integers()
    >>> list(chain)
    [1, 2, 3, 4, 5, 6, 7, 8]

到目前为止，还不是很有趣。但是，我们会马上对此进行更改。
你会看到，可以将生成器彼此“连接”起来，以构建像管道一样工作的高效数据处理算法。
你可以获取来自integers()生成器的数据“流”，然后将它们再次填入另一个生成器。
例如，一个计算每个数的平方，然后将其传下去的生成器：

    def squared(seq):
        for i in seq:
            yield i * i

这就是现在我们的“数据管道”或“生成器链”所要做的：

    >>> chain = squared(integers())
    >>> list(chain)
    [1, 4, 9, 16, 25, 36, 49, 64]

我们可以继续向该管道添加新的代码基块。
数据仅沿一个方向流动，通过明确定义的接口，每个处理步骤都和其他的步骤隔离起来。

这类似于Unix中管道的工作方式。、
我们将一系列的处理过程连接起来，以便每个过程的输出直接作为下一个的输入。

为什么不在我们的管道中添加另一个步骤来取每个值的负值，
然后将其传递到链中的下一个处理步骤呢：

    def negated(seq):
        for i in seq:
            yield -i

如果我们重建生成器链并在末尾添加`negated`，那么输出如下：

    >>> chain = negated(squared(integers()))
    >>> list(chain)
    [-1, -4, -9, -16, -25, -36, -49, -64]

关于生成器链，我最喜欢的事情是数据处理时一次只处理一个元素。
生成器连中的处理步骤之间没有缓存：

1. `integers`生成器产生单个值，比方说3。
2. 这将“激活”`squared`生成器，`squared`生成器将处理值，并将（3×3 = 9）传递到下一级
3. `squared`生成器产生的平方数立即进入`negated`生成器，`negated`生成器将其修改为-9并再次产出它。

你可以继续扩展生成器链，以建立一个包含许多步骤的处理管道。
它仍然可以高效执行，因为链中的每个步骤都是一个单独的生成器函数，修改也很轻松。

该处理管道中的每个单独的生成器函数都相当简洁。
只需一点技巧，我们就可以用更少的代码定义这个流水线，并且不会牺牲很多可读性：

    integers = range(8)
    squared = (i * i for i in integers)
    negated = (-i for i in squared)

请注意，我是如何用上一步输出产生的生成器表达式替换链中的每个处理步骤的。
上面的代码等效于我们在本章中构建的生成器链：

    >>> negated
    <generator object <genexpr> at 0x1098bcb48>
    >>> list(negated)
    [0, -1, -4, -9, -16, -25, -36, -49]

使用生成器表达式的唯一缺点是它们不能接受参数，
你无法在同一处理管道中多次重复使用相同的生成器表达式。

当然，在创建这些管道时，你可以混合使用生成器表达式和常规生成器定期。
这会对提高复杂管道的可读性有帮助。

### 重点
- 生成器可以链接在一起以形成高效和可维护的数据处理管道。
- 链式生成器单独处理经过管道的每个元素。
- 生成器表达式可用于编写简洁的管道定义，但这会影响可读性。
