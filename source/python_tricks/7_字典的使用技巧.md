# 第七章 字典的使用技巧

## 7.1 字典的默认值

Python的字典的`get()`方法可以在查找字典的键对应的值时提供默认值。
在许多情况下这会很方便。
让我举一个简单的例子来说明这个特性。
假设我们具有以下的数据结构，它将用户ID映射到用户名称：

    name_for_userid = {
        382: 'Alice',
        950: 'Bob',
        590: 'Dilbert',
    }

现在，我们使用此数据结构编写一个`greeting()`函数，
它会根据用户ID为用户返回问候语。
我们的第一个实现可能是这样：

    def greeting(userid):
        return 'Hi %s!' % name_for_userid[userid]

这是一个简单的字典查询。
这个实现从技术上讲可以运行，但前提是用户ID在`name_for_userid`字典中存在。
如果我们将无效的用户ID传递给`greeting()`函数会引发异常：

    >>> greeting(382)
    'Hi Alice!'
    >>> greeting(33333333)
    KeyError: 33333333

`KeyError`异常并不是我们希望看到的结果。 
在找不到用户ID时，如果函数返回通用问候语会更好。

让我们实现这个想法。
我们的第一种方法可能是简单地检查键是否在字典中，
如果用户ID不存在，则返回默认的问候。

    def greeting(userid):
        if userid in name_for_userid:
            return 'Hi %s!' % name_for_userid[userid]
        else:
            return 'Hi there!'

让我们看看这个`greeting()`的实现在之前的测试用例上表现如何：

    >>> greeting(382)
    'Hi Alice!'
    >>> greeting(33333333)
    'Hi there!'

好多了。
现在，我们对未知用户我们可以有一个通用的问候，
并且用户ID有效时，我们会保留个性化的问候。

但是这仍有改进的空间。
尽管新的实现结果和我们预期的一样，
并且看起来足够小巧，整洁，
但是它仍然可以改进。
我对当前方法的了解：

- 效率低下，因为它查询了两次字典。
- 冗长，比如，问候字符串的一部分有重复。
- 不Pythonic——官方Python文档推荐在这种场景下采用“寻求宽恕比许可容易”（EAFP）的编码风格：
  “这种通用的Python编码风格假定键或属性存在，并在假设错时捕获异常。”
  
一个更好的、遵循EAFP原则的实现可能会使用`try…except`块来捕获`KeyError`
而不是显式地对key存在性进行检查：

    def greeting(userid):
        try:
            return 'Hi %s!' % name_for_userid[userid]
        except KeyError:
            return 'Hi there'

就我们的最开始的需求而言，这个实现是没有问题的，
现在，我们不再需要查询字典两次。
但是我们仍然可以进一步改善它，并提供更整洁的方案。
Python的字典有一个`get()`方法，该方法支持一个可用作后备值的“默认”参数：

    def greeting(userid):
        return 'Hi %s!' % name_for_userid.get(userid, 'there')

调用`get()`时，它将检查字典中是否存在给定的键。
如果存在，则返回键的值。如果不存在，则返回默认参数的值。
`greeting`函数的这种实现仍然可以按预期工作：

    >>> greeting(950)
    'Hi Bob!'
    >>> greeting(333333)
    'Hi there!'

我们最终的`greeting()`实现简明，整洁且仅使用Python标准库中的功能。
因此，我相信这是这种特殊场景的最佳解决方案。

### 重点
- 在测试见是否在字典中时，避免显式使用`key in dict`进行检查。
- EAFP样式的异常处理或使用内置的`get()`方法是首选。
- 在某些情况下，标准库中的`collections.defaultdict`也很有用。


## 7.2 排序字典的乐趣和收益

Python字典没有固有的顺序。
你可以对其进行遍历，但是不能保证迭代以任何特定顺序返回字典中的元素（尽管这种情况在Python 3.6已经发生变化）。

但是，获得字典的排序表示通常是很有用的，
排序可根据字典的键，值或其他衍生属性将键值对按任意顺序排列。
假设你有一个字典xs，其内容如下：

    >>> xs = {'a': 4, 'c': 2, 'b': 3, 'd': 1}

要获得此字典中键值对的排序列表，
你可以先使用字典的`items()`方法，然后再对结果序列进行排序：

    >>> sorted(xs.items())
    [('a', 4), ('b', 3), ('c', 2), ('d', 1)]

为了比较序列，键值对元组使用Python标准的字典序进行排序。

为了比较两个元组，Python首先比较索引为零处的元素。
如果它们不同，则索引为零处元素的比较结果就是两个元组比较的结果。
如果它们相等，则比较索引为1的两个元素，依此类推。

现在，因为这些元组是从字典中获取的，每个元组中索引为零的元素都是字典的键，
考虑到字典的键都是唯一的，所以元组索引为零处的元素都是唯一的。
所以，这里没有特殊情况要处理。

在某些情况下，按字典顺序排序可能已经满足了你的需求。
在其他情况下，你可能希望按值对字典进行排序。
幸运的是，有一种方法可以完全控制元素的排序方式。
你可以通过将`key`函数传递给`sorted(`)函数来控制排序结果，`sorted()`函数可以改变字典元素的比较方式。

`key`函数只是在每个元素比较之前调用的普通Python函数。
`key`函数以字典元素作为输入，返回排序比较所需的“键”。

不幸的是，“`key`”一词在两种情况下都有使用，
在这里`key`函数和字典键无关，它仅将每个输入元素映射为用于比较的值。

现在，也许我们应该看一个例子。
相信我，在看到一些真实的代码后`key`函数会更容易理解。

假设你想获得按值排序的字典。
要获得此结果，你可以使用下面的`key`函数，
它通过查找元组中的第二个元素来返回每个键值对的值：

    >>> sorted(xs.items(), key=lambda x: x[1])
    [('d', 1), ('c', 2), ('b', 3), ('a', 4)]

看看存储键值对的结果列表是如何根据原始字典中存储的键值对的值进行排序的。
值得花一些时间研究一下`key`函数的工作原理。
你可以在各种Python上下文中应用它，这是一个很有用的概念。

实际上，这一概念非常普遍，以至于Python的标准库包含了`operator`模块。
该模块实现了一些最常用的key函数作为即插即用的构建基块，
例如，`operator.itemgetter`和`operator.attrgetter`。

这里有一个示例，说明如何在第一个示例中使用`operator.itemgetter`替换使用`lambda`的索引查找：

    >>> import operator
    >>> sorted(xs.items(), key=operator.itemgetter(1))
    [('d', 1), ('c', 2), ('b', 3), ('a', 4)]

在某些情况下，使用`operator`模块可能会更清楚地传达你的意图。
另一方面，使用简单的`lambda`表达式可能既可读又明确。
在这种特殊情况下，我实际上更倾向于使用`lambda`表达式。

使用`lambda`作为自定义`key`函数的另一个好处是你可以以更精细的方式控制排序顺序。
例如，你可以根据每个值的绝对数值对字典进行排序：

    >>> sorted(xs.items(), key=lambda x: abs(x[1]))

如果你需要颠倒排序顺序让较大的值排在最前面，
可以在调用`sorted()`时使用`reverse=True`关键字参数：

    >>> sorted(xs.items(),
               key=lambda x: x[1],
               reverse=True)
    [('a', 4), ('b', 3), ('c', 2), ('d', 1)]

就像我之前说过的，花点时间去掌握`key`函数在Python中的运行原理是完全值得的。
他们为你提供了很多灵活性，通常可以使你免于编写代码进行数据结构转换的麻烦。

### 重点

- 创建字典和其他集合的排序的“视图”时，你可以使用`key`函数来控制排序结果。
- `key`函数是Python中的重要概念。
  最常用的`key`函数甚至添加到了Python标准库的`operator`模块中。
- 函数是Python中的一等公民。这是一个在该语言中随处可见的强大的功能。

## 7.3 用字典模拟switch/case语句

Python没有`switch/case`语句，
因此有时需要写很长的`if...elif...else`语句来解决这个问题。
在本章中，你会找到一个技巧，该技巧可以使用字典和一等函数模拟`switch/case`语句。
听起来令人兴奋？太好了，我们开始！

想象一下，我们的程序中有以下if语句：

    >>> if cond == 'cond_a':
    ...     handle_a()
    ... elif cond == 'cond_b':
    ...     handle_b()
    ... else:
    ...     handle_default()

当然，只有三种不同的条件，这并不太可怕。
但是，试想一下，如果我们在此语句中有十个或更多个elif分支。
事情就会有所不同。
我认为过长的if语句是一种代码异味，它让程序更难阅读和维护。

处理长`if...elif...else`语句的一种方法是使用字典查找表进行替换，
它可以模拟`switch/case`语句的行为。

这里的想法是利用Python具有一等函数这一事实。
这意味着它们可以作为参数传递给其他函数，
作为其他函数的值返回，
賦值给变量和存储在数据结构中。

例如，我们可以定义一个函数，然后将其存储在列表中并在以后进行访问：

    >>> def myfunc(a, b):
    ...     return a + b
    ...
    >>> funcs = [myfunc]
    >>> funcs[0]
    <function myfunc at 0x107012230>

调用此函数的语法符合你的直觉期望，
我们只需在列表中使用索引，然后使用“()”语法调用函数并将参数传递给它：

    >>> funcs[0](2, 3)
    5

现在，我们如何使用一等函数来减少很长的if语句的大小？
这里的核心思想是定义字典，
将输入条件的查找键映射到执行预期操作的函数上：

    >>> func_dict = {
    ...     'cond_a': handle_a,
    ...     'cond_b': handle_b
    ... }

我们可以通过字典键查找来获取处理函数，然后调用它，而不是通过if语句检查每个条件然后进行过滤：

    >>> cond = 'cond_a'
    >>> func_dict[cond]()

这个实现已经可以工作了，
至少当cond可以在字典中找到时是如此。
如果cond不在字典中，我们将收到一个`KeyError`异常。

因此，让我们寻找一种方法来支持默认场景以与原来的`else`分支对应。
幸运的是，所有Python字典都具有`get()`方法，
它可以返回给定键值的值，如果键不存在则返回默认值。
这正是我们在这里需要的：

    >>> func_dict.get(cond, handle_default)()

最初，这段代码在语法上可能看起来很奇怪，
但是当你对其进行分解后，会发现它的工作原理与前面的示例完全相同。
我们使用Python的一等函数将`handle_default`传递给`get()`作为默认值。
这样，在字典中找不到条件时，我们可以避免抛出`KeyError`异常，直接调用默认处理函数进行处理。

让我们看一个更完整的示例，该示例使用字典查找和一等函数替换`if`语句。
通读以下示例后，你将能够看到将某些类型的`if`语句转换为基于字典的调度所需的模式。

我们将使用`if`语句编写另一个函数，然后对其进行转换。
该函数采用字符串操作码，例如“add”或“mul”，然后对操作数x和y进行一些数学运算：

    >>> def dispatch_if(operator, x, y):
        ... if operator == 'add':
        ...     return x + y
        ... elif operator == 'sub':
        ...     return x - y
        ... elif operator == 'mul':
        ...     return x * y
        ... elif operator == 'div':
        ...     return x / y

老实说，这只不过是另一个玩具示例（我不想用整页整页的代码让你觉得无聊），
但可以很好地说明底层的设计模式。 
一旦“获得”模式，你将能够在各种不同的场景进行应用。

你可以通过在调用`dispatch_if()`函数时，传入字符串操作码和两个数字来尝试执行简单的计算：

    >>> dispatch_if('mul', 2, 8)
    16
    >>> dispatch_if('unknown', 2, 8)
    None

请注意，“未知”场景同样可以工作，
因为Python在任何函数的末尾添加了一个隐式的`return None`语句。

到现在为止还挺好。
让我们将原始的`dispatch_if()`转换为一个新函数，
这个新函数使用字典将操作码映射到算术运算函数。

    >>> def dispatch_dict(operator, x, y):
    ...     return {
    ...         'add': lambda: x + y,
    ...         'sub': lambda: x - y,
    ...         'mul': lambda: x * y,
    ...         'div': lambda: x / y,
    ...     }.get(operator, lambda: None)()

这种基于字典的实现与初始的`dispatch_if()`输出同样的结果。
我们可以完全相同的方法调用这两个函数：

    >>> dispatch_dict('mul', 2, 8)
    16
    >>> dispatch_dict('unknown', 2, 8)
    None

如果是真正的“生产”代码，有一些方法可以这些代码进行改进。

首先，每次我们调用`dispatch_dict()`时，
它都会创建一个临时字典和一堆用于操作码查找的`lambda`函数。
这从性能角度来看并不理想。
对于追求性能的代码，将字典创建为常量然后在调用函数时引用它会更有意义。
我们不想在每次需要查找时都重新创建字典。

其次，如果我们真的想做一些诸如`x + y`的简单算术运算，
那么最好使用Python的内置的`operator`模块而不是示例中使用的`lambda`函数。
`operator`模块为所有Python运算符提供了实现，
例如o`perator.mul`，`operator.div`等。
这是次要点。
在此示例中，我有意使用了`lambda`使它更通用。
这可以让你在其他场景下也可以应用该模式。

好了，现在你有了很多技巧，
可以使用它们来简化一些`if`链，以防它们变得笨拙。
请记住，这项技术并非在所有情况下都适用，
有时你可以使用简单的`if`语句来获得更好的收益。

### 重点
- Python没有`switch/case`语句。
  但是在某些情况下，可以使用基于字典的调度表来避免过长的`i`f链。
- Python的一等函数功能很强大。但是，强大的力量伴随着巨大的责任。

## 7.4 最疯狂的字典表达式 

有时，你遇到的是一个真正有深度的小示例——如果你对代码进行了充分的思考，
那么一行代码就可以教给你很多关于编程语言的知识。
这样的代码片段感觉就像是Zenkōan：
禅宗练习中使用的一个问题或陈述，引起了疑问并测试了学生的学习进度。

我们将在本节中讨论的小段代码就是这样的一个例子。
乍一看，它看起来像是一个简单的字典表达式，
但是如果更进一步思考，它将通过CPython解释器带你进入思维扩展之旅。

我从这个行代码中获得了巨大的帮助，
有一次我将它打印在我的Python会议徽章上作为谈话的开始。
这也使我与我的成员进行了一些有益的对话。

因此，事不宜迟，这里是代码段。
花一点时间来思考一下下面的字典表达式及其计算结果：

    >>> {True: 'yes', 1: 'no', 1.0: 'maybe'}

我会在这里停一下...
准备好了吗？
这是在CPython解释器会话中上述字典表达式的结果：

    >>> {True: 'yes', 1: 'no', 1.0: 'maybe'}
    {True: 'maybe'}

我承认，当我第一次看到这个结果时，我感到非常惊讶。
但是，当你逐步调查发生了什么时，这一切都是合理的。
因此，让我们考虑一下为什么我们会得到这个有点不直观的结果。

当Python处理字典表达式时，它首先构造一个新的空字典对象。
然后按字典表达式中指定的顺序为其分配键和值。

因此，当我们对其进行分解后，上面的字典表达式等效于按顺序执行以下语句：

    >>> xs = dict()
    >>> xs[True] = 'yes'
    >>> xs[1] = 'no'
    >>> xs[1.0] = 'maybe'

奇怪的是，Python认为这个例子中使用的所有字典键都相等：

    >>> True == 1 == 1.0
    True

好的，先稍等片刻。
我敢肯定，你可以接受1.0 ==　1，
但是为什么True也被认为等于1？
我第一次看到这个表达式时，确实感到困惑。

在Python文档中进行了一些挖掘之后，
我了解到Python将`bool`视为`int`的子类。
在Python 2和Python 3中就是这种情况。

> “布尔类型是整数类型的子类型，
> 并且在几乎所有上下文中布尔值的行为类似于值0和1，
> 唯一的例外是当转换为字符串时，会分别返回字符串'False'或'True'。

是的，这意味着你可以使用布尔作为Python中列表或元组的索引：

    >>> ['no', 'yes'][True]
    'yes'

为了保持清代码清晰，你不应该这样使用布尔值变量（为了你的同事能够保持理智）。

无论如何，让我们回到字典表达式中。

就Python而言，`True`，1和1.0都代表相同的字典键。
在解释器执行字典表达式时，它会反复覆盖键`True`的值。
这就解释了为什么最终的字典中只包含一个键。

在继续之前，让我们再看一下原始的字典表达式：

    >>> {True: 'yes', 1: 'no', 1.0: 'maybe'}
    {True: 'maybe'}

为什么我们在这里仍然将`True`作为键？
因为重复的覆盖，键不应该在最后变为1.0吗？

在CPython解释器源代码中进行了一些研究之后，
我了解到Python的字典不会在与新对象相关联时更新键对象本身：

    >>> ys = {1.0: 'no'}
    >>> ys[True] = 'yes'
    >>> ys
    {1.0: 'yes'}

当然，这对性能优化是有意义的——如果键是相同的，那么为什么要花时间来更新原始的键呢？

在上一个示例中，你看到了初始`True`对象作为键从未被替换。
因此，字典的字符串表示形式仍将键显示为`True`（而不是1或1.0）。

现在我们知道，字典中的值看上去只是因为相等而被覆盖。
但是，事实证明，这种效果也不是仅由`__eq__`相等性检查引起的。

Python词典以哈希表数据结构作为底层实现。
当我第一次看到这个令人惊讶的字典表达式时，
我的直觉是这种行为与哈希冲突有关。

哈希表根据每个键的哈希值将其所有的键存储在不同的“桶”中。
哈希值是从键中获取的，这个值是一个固定长度的数字，用来唯一标识键。

这允许快速查找。
与将完整键对象与所有其他键进行比较并检查是否相等相比，
在查找表中搜索键的数字哈希值要快得多。

但是，通常计算哈希值的方法并不完美。
最终，实际上不同的两个或更多个键将具有相同的哈希值，
并且最终将出现在相同的查找表存储桶中。

两个键具有相同的哈希值，称为哈希冲突，
这是一种特殊情况，哈希表的插入和查找算法需要处理这种情况。

根据上面的分析，很可能哈希与我们从字典表达式中获得的令人惊讶的结果有关。
因此，让我们在这里查看键的哈希值是否也在起作用。

我定义了下面的类作为我们的小侦探工具：

    class AlwaysEquals:
        def __eq__(self, other):
            return True

        def __hash__(self):
            return id(self)

此类在两个方面很特殊。
首先，由于其`__eq__`下划线方法始终返回True，
因此此类的所有实例都将假装它们等于任何其他对象：

    >>> AlwaysEquals() == AlwaysEquals()
    True
    >>> AlwaysEquals() == 42
    True
    >>> AlwaysEquals() == 'waaat?'
    True

其次，每个`AlwaysEquals`实例还将返回由内置`id()`函数生成的唯一哈希值：

    >>> objects = [AlwaysEquals(),
    AlwaysEquals(),
    AlwaysEquals()]
    >>> [hash(obj) for obj in objects]
    [4574298968, 4574287912, 4574287072]

在CPython中，`id()`返回内存中对象的地址，该地址被保证是唯一的。

通过此类，我们现在可以创建与其他任何对象都相同但具有唯一哈希值的对象。
这样一来，我们可以测试字典的键是仅仅否因为他们的相等性比较而被覆盖。

而且，你看，即使它们始终相等，示例中的键也不会被覆盖：

    >>> {AlwaysEquals(): 'yes', AlwaysEquals(): 'no'}
    { <AlwaysEquals object at 0x110a3c588>: 'yes',
    <AlwaysEquals object at 0x110a3cf98>: 'no' }

我们也可以将换个思路，看看是否哈希值相同就会导致键被覆盖：

    class SameHash:
        def __hash__(self):
            return 1
            
`SameHash`类的实例彼此不相等，但它们具有相同的哈希值1：

    >>> a = SameHash()
    >>> b = SameHash()
    >>> a == b
    False
    >>> hash(a), hash(b)
    (1, 1)
    
让我们看看当我们将`SameHash`类的实例用作字典的键时，Python的字典的行为：

    >>> {a: 'a', b: 'b'} 
    { <SameHash instance at 0x7f7159020cb0>: 'a', 
      <SameHash instance at 0x7f7159020cf8>: 'b' }
      
从这个例子中可以看到，“键被覆盖”也不是仅由哈希值冲突引起的。

字典会检查两个值是否相等，并比较哈希值以确定两个键是否相同。
我们尝试总结一下我们的调查结果：
`{True：'yes'，1：'no'，1.0：'maybe'}`字典表达式的计算结果为`{True：'maybe'}`，
因为键`True`，1和1.0的值都相等，并且它们具有相同的哈希值：

    >>> True == 1 == 1.0
    True
    >>> (hash(True), hash(1), hash(1.0))
    (1, 1, 1)
    
也许不再那么令人惊讶了，这就是字典的最终状态为什么是这样的原因：

    >>> {True: 'yes', 1: 'no', 1.0: 'maybe'} 
    {True: 'maybe'}
    
我们在这里涉及了很多主题，
而这个Python技巧在开始时可能有点令人难以置信——这就是为什么我一开始将它与Zenkōan进行比较的原因。
如果难以理解本节的内容，可以尝试在Python解释器中逐一运行这些代码示例。
作为回报，你会掌握这些Python的底层知识。

### 重点

- 如果字典键相等（使用`__eq__`比较）且哈希值相同，则字典将它们视为相同的键。
- 意外的字典键冲突会导致令人惊讶的结果。


## 7.5 合并字典的多种方法

你是否曾经为一个Python程序构建过配置系统？
这种系统的常见场景是采用具有默认配置选项的数据结构，
然后允许从用户输入或其他配置源中有选择地覆盖默认值。

我经常发现自己使用字典作为表示配置信息的基础数据结构。
因此，我经常需要一种方法来组合或合并配置默认值和用户配置值到单个字典中。

或概括地说：有时你需要一种将两个或多个字典合并为一个字典的方法，
以便生成的字典包含所有源字典的键和值的合集。

在本章中，我将向你展示实现该目标的几种方法。
我们首先来看一个简单的示例，以便进行一些讨论。

假设有以下两个源字典：

    >>> xs = {'a': 1, 'b': 2}
    >>> ys = {'b': 3, 'c': 4}

现在，你想要创建一个包含xs和ys的所有键和值的新字典zs。
另外，如果你仔细阅读该示例，
你会发现字符串“b”这个键在两个字典中都存在——我们还需要考虑重复键的冲突解决策略。

Python中“合并多个词典”的经典解决方案是使用字典的`update()`方法：

    >>> zs = {}
    >>> zs.update(xs)
    >>> zs.update(ys)
    
如果你对其实现好奇，一个简单的`update()`实现可能像下面这样。
我们只需遍历右侧字典的所有项，然后将每个键值对添加到左侧字典中，就可以覆盖现有的键：

    def update(dict1, dict2):
        for key, value in dict2.items():
            dict1[key] = value
            
这会产生一个新的字典zs，这个字典现在包含在xs和ys中定义的所有键：

    >>> zs
    >>> {'c': 4, 'a': 1, 'b': 3}
    
我们调用`update()`的顺序决定了解决冲突的方式。
最后一次更新影响了最终的结果，
重复键“b”的值与第二个源词典ys的值3相等。

当然，只要你愿意，就可以扩展这个`update()`调用链，以便将任意数量的字典合并为一个。
这是一种实用且易于理解的解决方案，可以在Python 2和Python 3中使用。

在Python 2和Python 3中另一种有效技术是组合使用内置的`dict()`与用来“解包”对象的**运算符：

    >>> zs = dict(xs, **ys)
    >>> zs
    {'a': 1, 'c': 4, 'b': 3}

但是，就像重复进行`update()`调用一样，
这个方法仅适用于合并两个字典，并且不能在一步中组合任意数量的字典。

从Python 3.5开始，**运算符变得更加灵活。
在Python 3.5+中，还有另一种是更漂亮的合并任意数量字典的方式：

    >>> zs = {**xs, **ys}

该表达式的结果与`update()`调用链的结果完全相同。
键和值以从左到右的顺序设置，因此这里的冲突解决策略是相同的：右侧优先，
并且ys中的值将覆盖xs中相同键下的值。
当我们查看合并操作产生的字典时，这一点就变得很清楚了：

    >>> zs
    >>> {'c': 4, 'a': 1, 'b': 3}

就我个人而言，我喜欢这种新语法的简洁性，同时它还有足够高的可读性。
冗长和简洁之间总是要有一个很好的平衡，以使代码具有尽可能高的可读性和可维护性。

在这种场景下，如果我使用的是Python 3，
会更倾向于使用新语法。
使用**运算符还比使用链接的`update()`要快，这是另一个好处。

### 重点

- 在Python 3.5及更高版本中，你可以使用**运算符在单个表达式中将多个字典合并为一个，
  遇到重复的键时，右边的字典的键会覆盖左边字典的键。
- 为了与旧版本的Python兼容，你可能需要使用内置的`update()`方法。


## 7.6 整洁地输出字典

你是否曾经尝试通过一堆的“`print`”语句来跟踪执行流程，以解决程序中的一个bug？
或者，也许你需要生成一条日志来打印一些配置设置……

某些Python中的数据结构作为文本字符串打印时，会很难阅读，这经常让我感到沮丧。
例如，这是一个简单的字典。在解释器会话中打印时，键的顺序是任意的，并且结果字符串没有缩进：

    >>> mapping = {'a': 23, 'b': 42, 'c': 0xc0ffee}
    >>> str(mapping)
    {'b': 42, 'c': 12648430, 'a': 23}
    
幸运的是，有一些易于使用的替代方法，可以直接将字典转换为字符串，从而获得更具可读性的结果。
一种选择是使用Python内置的`json`模块。
你可以使用`json.dumps()`以更好的格式打印Python字典：

    >>> import json
    >>> json.dumps(mapping, indent=4, sort_keys=True)

    {
        "a": 23,
        "b": 42,
        "c": 12648430
    }

这些设置会产生一个具有很好缩进的字符串表示形式，
这个字符串表示还规范了键的顺序以提高可读性。

虽然看起来不错，而且可读性强，但这并不是一个完美的解决方案。
使用`json`模块打印字典仅适用于包含基础类型的字典——尝试打印包含像函数这类非原始数据类型的字典会遇到麻烦：

    >>> json.dumps({all: 'yup'})
    TypeError: "keys must be a string"

使用`json.dumps()`的另一个缺点是，它无法将复杂的数据类型（例如集合）转换为字符串：

    >>> mapping['d'] = {1, 2, 3}
    >>> json.dumps(mapping)
    TypeError: "set([1, 2, 3]) is not JSON serializable"

另外，你可能会遇到Unicode文本表示方式的麻烦——在某些情况下，
你将`json.dumps`的输出复制粘贴到Python解释器会话中以重建原始字典对象。

内置的`pprint`模块是在Python中整洁打印对象的经典解决方案。
这是一个例子：

    >>> import pprint
    >>> pprint.pprint(mapping)
    {'a': 23, 'b': 42, 'c': 12648430, 'd': set([1, 2, 3])}

你可以看到`pprint`能够打印数据集（例如集合），并且还可以以可重复的顺序打印字典键。
与字典的标准字符串表示相比，这要养眼得多。

但是，与`json.dumps()`相比，它也无法在视觉上表示嵌套结构。
根据情况，这可能是优点或缺点。
由于可读性和格式的改进，我偶尔会使用`json.dumps()`打印字典，
但前提是我确定它们没有非原始数据类型。

### 重点

- Python中字典对象默认的字符串转换结果可能很难阅读。
- `pprint`和`json`模块是Python标准库中内置的“高保真”选项。
- 同时使用`json.dumps()`和非基础类型的键和值时要小心，因为这会触发`TypeError`
